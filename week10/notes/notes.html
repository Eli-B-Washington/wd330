<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eli Bear's Week 10 Notes</title>
  <link rel="stylesheet" href="../../css/style.css">
  
</head>


<body>
  <h1>Week 10 Notes</h1>

<pre>
  Validating Forms:
  Client-side validation making sure all forms are filled out correctly on the client-side
  Validation should happen on the client and server Client-side

  2 types - 
  Built in validation.  doesn't require much javascript. fasyer, not very custumizable

  javascript - harder to implement, but completely custumizable

  required: Specifies whether a form field needs to be filled in before the form can be submitted.
  minlength and maxlength: Specifies the minimum and maximum length of textual data (strings)
  min and max: Specifies the minimum and maximum values of numerical input types
  type: Specifies whether the data needs to be a number, an email address, or some other specific preset type. 
  pattern: Specifies a regular expression that defines a pattern the entered data needs to follow.

  if an element is valid:

  :valid CSS (psuedo-class)
  form will submit

  if element is invalid:
  :invalid CSS (psuedo-class)
  form will not submit.

  the required attriubte makes a form value required.

  required pattern

  input id="choose" name="i_like" required pattern="[Bb]anana|[Cc]herry">

  example to add custom javascript error message to a form using an event listener.

  form>
    label for="mail">I would like you to provide me with an e-mail address:/label>
    input type="email" id="mail" name="mail">
    button>Submit/button>
  /form>


  const email = document.getElementById("mail");

  email.addEventListener("input", function (event) {
    if (email.validity.typeMismatch) {
      email.setCustomValidity("I am expecting an e-mail address!");
    } else {
      email.setCustomValidity("");
    }
  });


  The Fetch API -
  (did this a little bit is CS313)

  provides a javascript interface for manipulating parts of the HTTP pipeline,
   such as requests and responses.
  It also provides a global fetch() method.

  fetch('http://example.com/movies.json')
  .then(response => response.json())
  .then(data => console.log(data));

  // Example POST method implementation with init parameters:
async function postData(url = '', data = {}) {
  // Default options are marked with *
  const response = await fetch(url, {
    method: 'POST', // *GET, POST, PUT, DELETE, etc.
    mode: 'cors', // no-cors, *cors, same-origin
    cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
    credentials: 'same-origin', // include, *same-origin, omit
    headers: {
      'Content-Type': 'application/json'
      // 'Content-Type': 'application/x-www-form-urlencoded',
    },
    redirect: 'follow', // manual, *follow, error
    referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, 
    origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, 
    unsafe-url
    body: JSON.stringify(data) // body data type must match "Content-Type" header
  });
  return response.json(); // parses JSON response into native JavaScript objects
 }

postData('https://example.com/answer', { answer: 42 })
  .then(data => {
    console.log(data); // JSON data parsed by `data.json()` call
  });


  From the reading:
  Instead of passing a path to the resource you want to request into the fetch() call,
   you can create a request object using the Request() constructor, and pass that in as a fetch()
    method argument:

    
</pre>


  <h1>Questions</h1>
  <p>
    Is it best to have built in AND javascript client side validation or is it better to choose one?
    </p>
</body>

</html>